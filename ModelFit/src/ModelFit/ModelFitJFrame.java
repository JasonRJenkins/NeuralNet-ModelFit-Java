/////////////////////////////////////////////////////////////////////
//
// Implements the ModelFitJFrame class
//
// Author: Jason Jenkins
//
// This class implements the form based GUI used by the application.
//
/////////////////////////////////////////////////////////////////////

package ModelFit;

/////////////////////////////////////////////////////////////////////

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import java.util.ArrayList;
import java.util.Collections;

import java.awt.Color;
import java.awt.Cursor;

import javax.swing.JOptionPane;
import javax.swing.JFileChooser;
import javax.swing.DefaultListModel;
import javax.swing.table.DefaultTableModel;
import javax.swing.filechooser.FileNameExtensionFilter;

/////////////////////////////////////////////////////////////////////

import Data.Table.*;
import NeuralNetwork.*;
import NeuralNetwork.NetUnit.*;
import NeuralNetwork.NetTrainer.*;

/////////////////////////////////////////////////////////////////////
/**
 * This class implements the form based GUI used by the ModelFit application.
 *
 * The form allows the user to explore the various settings that can be applied
 * to a simple single hidden layer neural network that can be used to model the 
 * potential relationship between a single predictor variable (X) and a single 
 * corresponding response variable (Y) chosen from a selected .CSV data file.
 *
 * The results of the model fit can be saved to .CSV file and the trained 
 * network can also be serialized and saved to a file.
 * 
 * @author Jason Jenkins
 */
public class ModelFitJFrame extends javax.swing.JFrame
{
    /////////////////////////////////////////////////////////////////////
    // Private Data Members
    /////////////////////////////////////////////////////////////////////

    /**
     * the name of data file (including the full path)
     */
    private String mDataFile;
    
    /**
     * the data table column index of the selected predictor variable (X)
     */
    private int mPredictorIdx = -1;
    
    /**
     * the data table column index of the selected response variable (Y)
     */
    private int mResponseIdx = -1;
    
    /**
     * the neural network used to fit models to the data
     */
    private NeuralNet mNet = new NeuralNet();
    
    /**
     * used to store the data file as a table
     */
    private DataTable mDataTable = new DataTable();
    
    /**
     * the training set input vectors
     */
    private ArrayList<ArrayList<Double>> mInputVecs = new ArrayList<ArrayList<Double>>();
    
    /**
     * the training set target vectors
     */
    private ArrayList<ArrayList<Double>> mTargetVecs = new ArrayList<ArrayList<Double>>();
    
    /////////////////////////////////////////////////////////////////////
    // Constructor    
    /////////////////////////////////////////////////////////////////////
    /**
     * Creates new form ModelFitJFrame
     */
    public ModelFitJFrame()
    {
        initComponents();
        
        // populates the form's Activation function list boxes
        populateActivationListBoxes();
        
        // initially clear the data preview table
        dataPreviewTable.setModel(new DefaultTableModel());
    }

    /////////////////////////////////////////////////////////////////////
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        statusLabel = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        dataFileTextField = new javax.swing.JTextField();
        fileBrowseBtn = new javax.swing.JButton();
        headerCheckBox = new javax.swing.JCheckBox();
        exitBtn = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        dataPreviewTable = new javax.swing.JTable();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane7 = new javax.swing.JScrollPane();
        xVarList = new javax.swing.JList<>();
        jPanel1 = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        outFuncList = new javax.swing.JList<>();
        outAmpSpinner = new javax.swing.JSpinner();
        jLabel5 = new javax.swing.JLabel();
        outSlopeSpinner = new javax.swing.JSpinner();
        jLabel6 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        yVarList = new javax.swing.JList<>();
        jLabel7 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        jLabel8 = new javax.swing.JLabel();
        jScrollPane5 = new javax.swing.JScrollPane();
        hidFuncList = new javax.swing.JList<>();
        hidAmpSpinner = new javax.swing.JSpinner();
        jLabel9 = new javax.swing.JLabel();
        hidSlopeSpinner = new javax.swing.JSpinner();
        jLabel10 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        learnConstSpinner = new javax.swing.JSpinner();
        momentSpinner = new javax.swing.JSpinner();
        minErrorSpinner = new javax.swing.JSpinner();
        numIterSpinner = new javax.swing.JSpinner();
        jLabel14 = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();
        jLabel16 = new javax.swing.JLabel();
        scaleFacSpinner = new javax.swing.JSpinner();
        initRangeSpinner = new javax.swing.JSpinner();
        numUnitsSpinner = new javax.swing.JSpinner();
        jLabel17 = new javax.swing.JLabel();
        jLabel18 = new javax.swing.JLabel();
        jLabel19 = new javax.swing.JLabel();
        jPanel3 = new javax.swing.JPanel();
        saveNetworkBtn = new javax.swing.JButton();
        saveModelBtn = new javax.swing.JButton();
        fitModelBtn = new javax.swing.JButton();
        infoLabel = new javax.swing.JLabel();
        iterationsLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("ModelFit");
        setMinimumSize(new java.awt.Dimension(850, 577));
        setName("modelFitFrame"); // NOI18N
        setPreferredSize(new java.awt.Dimension(850, 577));

        statusLabel.setText(" Status: Idle             ");
        statusLabel.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel1.setText("Data File ");

        dataFileTextField.setEditable(false);
        dataFileTextField.setToolTipText("displays the full name and path of the data file");

        fileBrowseBtn.setText("Browse");
        fileBrowseBtn.setToolTipText("click to browse for a CSV data file");
        fileBrowseBtn.setMaximumSize(new java.awt.Dimension(85, 23));
        fileBrowseBtn.setMinimumSize(new java.awt.Dimension(85, 23));
        fileBrowseBtn.setPreferredSize(new java.awt.Dimension(85, 23));
        fileBrowseBtn.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                fileBrowseBtnActionPerformed(evt);
            }
        });

        headerCheckBox.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        headerCheckBox.setSelected(true);
        headerCheckBox.setText("File has header row");
        headerCheckBox.setToolTipText("check if the data file has a header row");
        headerCheckBox.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                headerCheckBoxActionPerformed(evt);
            }
        });

        exitBtn.setText("Exit");
        exitBtn.setToolTipText("click to exit the application");
        exitBtn.setMaximumSize(new java.awt.Dimension(85, 23));
        exitBtn.setMinimumSize(new java.awt.Dimension(85, 23));
        exitBtn.setPreferredSize(new java.awt.Dimension(85, 23));
        exitBtn.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                exitBtnActionPerformed(evt);
            }
        });

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel2.setText("Data Preview ");

        dataPreviewTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][]
            {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String []
            {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        )
        {
            boolean[] canEdit = new boolean []
            {
                false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex)
            {
                return canEdit [columnIndex];
            }
        });
        dataPreviewTable.setToolTipText("displays the first 100 lines of the data file - the last two rows contain the min and max values");
        jScrollPane1.setViewportView(dataPreviewTable);

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel3.setText("Predictor Variable (X)");

        xVarList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        xVarList.setToolTipText("select the data column containing the predictor variable (X)");
        xVarList.setAutoscrolls(false);
        xVarList.addListSelectionListener(new javax.swing.event.ListSelectionListener()
        {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt)
            {
                xVarListValueChanged(evt);
            }
        });
        jScrollPane7.setViewportView(xVarList);

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Output Layer", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 1, 11))); // NOI18N

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel4.setText("Activation Function");

        outFuncList.setModel(new javax.swing.AbstractListModel<String>()
        {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        outFuncList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        outFuncList.setToolTipText("select the output layer units activation function");
        outFuncList.addListSelectionListener(new javax.swing.event.ListSelectionListener()
        {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt)
            {
                outFuncListValueChanged(evt);
            }
        });
        jScrollPane2.setViewportView(outFuncList);

        outAmpSpinner.setModel(new javax.swing.SpinnerNumberModel(1.0d, 0.01d, 100.0d, 1.0d));
        outAmpSpinner.setToolTipText("used to boost or reduce the output layer units signal value");
        outAmpSpinner.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                outAmpSpinnerStateChanged(evt);
            }
        });

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel5.setText("Amplify:");
        jLabel5.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);

        outSlopeSpinner.setModel(new javax.swing.SpinnerNumberModel(1.0d, 1.0E-6d, 1000000.0d, 1.0d));
        outSlopeSpinner.setToolTipText("used to adjust the sensitivity of the output layer units activation function");
        outSlopeSpinner.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                outSlopeSpinnerStateChanged(evt);
            }
        });

        jLabel6.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel6.setText("Slope:");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel6))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane2)
                    .addComponent(outAmpSpinner)
                    .addComponent(outSlopeSpinner)))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(outSlopeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel6))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(outAmpSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel5)))
        );

        yVarList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        yVarList.setToolTipText("select the data column containing the response variable (Y)");
        yVarList.setAutoscrolls(false);
        yVarList.addListSelectionListener(new javax.swing.event.ListSelectionListener()
        {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt)
            {
                yVarListValueChanged(evt);
            }
        });
        jScrollPane4.setViewportView(yVarList);

        jLabel7.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel7.setText("Response Variable (Y)");

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Hidden Layer", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 1, 11))); // NOI18N

        jLabel8.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel8.setText("Activation Function");

        hidFuncList.setModel(new javax.swing.AbstractListModel<String>()
        {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        hidFuncList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        hidFuncList.setToolTipText("select the hidden layer units activation function");
        hidFuncList.addListSelectionListener(new javax.swing.event.ListSelectionListener()
        {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt)
            {
                hidFuncListValueChanged(evt);
            }
        });
        jScrollPane5.setViewportView(hidFuncList);

        hidAmpSpinner.setModel(new javax.swing.SpinnerNumberModel(1.0d, 0.01d, 100.0d, 1.0d));
        hidAmpSpinner.setToolTipText("used to boost or reduce the hidden layer units signal value");
        hidAmpSpinner.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                hidAmpSpinnerStateChanged(evt);
            }
        });

        jLabel9.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel9.setText("Amplify:");
        jLabel9.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);

        hidSlopeSpinner.setModel(new javax.swing.SpinnerNumberModel(1.0d, 1.0E-6d, 1000000.0d, 1.0d));
        hidSlopeSpinner.setToolTipText("used to adjust the sensitivity of the hidden layer units activation function");
        hidSlopeSpinner.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                hidSlopeSpinnerStateChanged(evt);
            }
        });

        jLabel10.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel10.setText("Slope:");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel10))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel8, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane5)
                    .addComponent(hidAmpSpinner)
                    .addComponent(hidSlopeSpinner)))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(jLabel8)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(hidSlopeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel10))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(hidAmpSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel9)))
        );

        jLabel12.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel12.setText("Main Settings");

        jLabel13.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel13.setText("Learning Constant:");

        learnConstSpinner.setModel(new javax.swing.SpinnerNumberModel(0.01d, 0.001d, 10.0d, 0.005d));
        learnConstSpinner.setToolTipText("governs the 'size' of the steps taken down the error surface");
        learnConstSpinner.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                learnConstSpinnerStateChanged(evt);
            }
        });

        momentSpinner.setModel(new javax.swing.SpinnerNumberModel(0.0d, 0.0d, 1.0d, 0.005d));
        momentSpinner.setToolTipText("used to weight the search of the error surface to continue along the same 'direction' as the previous step");
        momentSpinner.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                momentSpinnerStateChanged(evt);
            }
        });

        minErrorSpinner.setModel(new javax.swing.SpinnerNumberModel(5.0d, 0.0d, 10000.0d, 0.5d));
        minErrorSpinner.setToolTipText("training will stop when the total network error is less than this value");
        minErrorSpinner.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                minErrorSpinnerStateChanged(evt);
            }
        });

        numIterSpinner.setModel(new javax.swing.SpinnerNumberModel(1000, 100, 500000, 100));
        numIterSpinner.setToolTipText("sets the maximum number of iterations for the training process");
        numIterSpinner.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                numIterSpinnerStateChanged(evt);
            }
        });

        jLabel14.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel14.setText("Momentum:");

        jLabel15.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel15.setText("Min. Network Error:");

        jLabel16.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel16.setText("Number of Iterations:");

        scaleFacSpinner.setModel(new javax.swing.SpinnerNumberModel(1000.0d, 1.0d, 100000.0d, 100.0d));
        scaleFacSpinner.setToolTipText("used to divide the data values to reduce their magnitude - this may improve the fit");
        scaleFacSpinner.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                scaleFacSpinnerStateChanged(evt);
            }
        });

        initRangeSpinner.setModel(new javax.swing.SpinnerNumberModel(2.0d, 1.0d, 50.0d, 1.0d));
        initRangeSpinner.setToolTipText("sets the range of the random values initially connecting the layers of the network, 2 represents -1 to +1");
        initRangeSpinner.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                initRangeSpinnerStateChanged(evt);
            }
        });

        numUnitsSpinner.setModel(new javax.swing.SpinnerNumberModel(4, 1, 100, 1));
        numUnitsSpinner.setToolTipText("sets the number of units in the hidden layer");
        numUnitsSpinner.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                numUnitsSpinnerStateChanged(evt);
            }
        });

        jLabel17.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel17.setText("Scale Factor:");

        jLabel18.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel18.setText("Initial Range:");

        jLabel19.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel19.setText("No. of Hidden Units:");

        jPanel3.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        saveNetworkBtn.setText("Save Network");
        saveNetworkBtn.setToolTipText("click to serialise the current trained neural network to a file");
        saveNetworkBtn.setEnabled(false);
        saveNetworkBtn.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                saveNetworkBtnActionPerformed(evt);
            }
        });

        saveModelBtn.setText("Save Model");
        saveModelBtn.setToolTipText("click to save the latest model output data");
        saveModelBtn.setEnabled(false);
        saveModelBtn.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                saveModelBtnActionPerformed(evt);
            }
        });

        fitModelBtn.setText("Fit Model");
        fitModelBtn.setToolTipText("click to start the training process and fit a model to the data");
        fitModelBtn.setEnabled(false);
        fitModelBtn.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                fitModelBtnActionPerformed(evt);
            }
        });

        infoLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        infoLabel.setForeground(java.awt.SystemColor.textHighlight);
        infoLabel.setText("Please select a data file");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addComponent(saveNetworkBtn)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(saveModelBtn)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 153, Short.MAX_VALUE)
                .addComponent(fitModelBtn))
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(infoLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(infoLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 11, Short.MAX_VALUE)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(saveNetworkBtn)
                    .addComponent(saveModelBtn)
                    .addComponent(fitModelBtn)))
        );

        iterationsLabel.setText(" ");
        iterationsLabel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        iterationsLabel.setOpaque(true);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(dataFileTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 450, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(fileBrowseBtn, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(headerCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 37, Short.MAX_VALUE)
                        .addComponent(exitBtn, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2)
                            .addComponent(jLabel3)
                            .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel7)
                            .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(8, 8, 8)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(9, 9, 9)
                                        .addComponent(jLabel12, javax.swing.GroupLayout.PREFERRED_SIZE, 77, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                .addComponent(jLabel13)
                                                .addComponent(jLabel15)
                                                .addComponent(jLabel14, javax.swing.GroupLayout.Alignment.TRAILING))
                                            .addComponent(jLabel16)
                                            .addComponent(jLabel17)
                                            .addComponent(jLabel18)
                                            .addComponent(jLabel19))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                            .addComponent(momentSpinner, javax.swing.GroupLayout.DEFAULT_SIZE, 80, Short.MAX_VALUE)
                                            .addComponent(learnConstSpinner)
                                            .addComponent(minErrorSpinner, javax.swing.GroupLayout.DEFAULT_SIZE, 80, Short.MAX_VALUE)
                                            .addComponent(numIterSpinner)
                                            .addComponent(scaleFacSpinner)
                                            .addComponent(initRangeSpinner)
                                            .addComponent(numUnitsSpinner))))
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(18, 18, 18)
                                .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addComponent(statusLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(iterationsLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(dataFileTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(fileBrowseBtn, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(headerCheckBox)
                    .addComponent(exitBtn, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 29, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jLabel7)
                    .addComponent(jLabel12))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 84, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 84, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel13)
                            .addComponent(learnConstSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(11, 11, 11)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(momentSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel14))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(minErrorSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel15))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(8, 8, 8)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(numIterSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel16))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(scaleFacSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel17))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(initRangeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel18))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(numUnitsSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel19))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(6, 6, 6)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(statusLabel)
                    .addComponent(iterationsLabel)))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /////////////////////////////////////////////////////////////////////
    // Message Handlers
    /////////////////////////////////////////////////////////////////////
    
    private void exitBtnActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_exitBtnActionPerformed
    {//GEN-HEADEREND:event_exitBtnActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitBtnActionPerformed

    private void fileBrowseBtnActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_fileBrowseBtnActionPerformed
    {//GEN-HEADEREND:event_fileBrowseBtnActionPerformed
        JFileChooser fileChooser = new JFileChooser();

        fileChooser.setCurrentDirectory(new File(System.getProperty("user.dir")));
        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);        
        fileChooser.addChoosableFileFilter(new FileNameExtensionFilter("csv files (*.csv)", "csv"));
        fileChooser.setAcceptAllFileFilterUsed(true);
                
        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) 
        {
            // display the wait cursor
            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            // when new data is aquired the model parameters must be set before we can fit a model
            fitModelBtn.setEnabled(false);
            saveModelBtn.setEnabled(false);
            saveNetworkBtn.setEnabled(false); 
            
            // load the CSV file containing the training data
            File selectedFile = fileChooser.getSelectedFile();
            loadData(selectedFile.getAbsolutePath());
            
            // reset the cursor
            setCursor(Cursor.getDefaultCursor());
        }        
    }//GEN-LAST:event_fileBrowseBtnActionPerformed

    private void headerCheckBoxActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_headerCheckBoxActionPerformed
    {//GEN-HEADEREND:event_headerCheckBoxActionPerformed
        mDataTable.setHeader(headerCheckBox.isSelected());

        // re-load the CSV file (if selected) to reflect the change in header status
        if (mDataFile.length() > 0)
        {
            loadData(mDataFile);
            populateVariableListBoxes();
        }                        
    }//GEN-LAST:event_headerCheckBoxActionPerformed

    private void fitModelBtnActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_fitModelBtnActionPerformed
    {//GEN-HEADEREND:event_fitModelBtnActionPerformed
        if (mPredictorIdx != -1 && mResponseIdx != -1)
        {
            // display the wait cursor
            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            // disable the GUI buttons
            exitBtn.setEnabled(false);
            fitModelBtn.setEnabled(false);
            fileBrowseBtn.setEnabled(false);
            saveModelBtn.setEnabled(false);
            saveNetworkBtn.setEnabled(false);

            // update the information text label and status bar
            infoLabel.setText("Training Started - Please wait...");
            statusLabel.setText(" Status: Running... ");
            iterationsLabel.setText(" Iterations: 0 - Network Error:");

            // update the state of the GUI
            update(getGraphics());

            // fit the model
            int result = fitModel();

            // reset the cursor
            setCursor(Cursor.getDefaultCursor());

            // update the information text label
            statusLabel.setText(" Status: Idle             ");

            // always re-enable the exit and browse buttons
            exitBtn.setEnabled(true);
            fileBrowseBtn.setEnabled(true);

            // only re-enable the rest of the controls if there is a valid result
            if (result == 0)
            {
                infoLabel.setText("Training Complete!");

                // enable the GUI buttons
                fitModelBtn.setEnabled(true);
                saveModelBtn.setEnabled(true);
                saveNetworkBtn.setEnabled(true);
            }
            else
            {
                infoLabel.setText("Training Terminated!");
                iterationsLabel.setText(" ");
            }
        }
        else
        {
            // the GUI should prevent these situations - but just in case - handle them anyway
            if (mPredictorIdx == -1 && mResponseIdx == -1)
            {
                JOptionPane.showMessageDialog(null, "You must select a predictor (X) and a response variable (Y).", 
                                                    "ModelFit", JOptionPane.ERROR_MESSAGE);
            }
            else if (mPredictorIdx == -1)
            {
                JOptionPane.showMessageDialog(null, "You have not selected a predictor variable (X).", 
                                                    "ModelFit", JOptionPane.ERROR_MESSAGE);
            }
            else
            {
                JOptionPane.showMessageDialog(null, "You have not selected a response variable (Y).", 
                                                    "ModelFit", JOptionPane.ERROR_MESSAGE);
            }
        }
    }//GEN-LAST:event_fitModelBtnActionPerformed

    private void xVarListValueChanged(javax.swing.event.ListSelectionEvent evt)//GEN-FIRST:event_xVarListValueChanged
    {//GEN-HEADEREND:event_xVarListValueChanged
        mPredictorIdx = xVarList.getSelectedIndex();
        updateInfo();
    }//GEN-LAST:event_xVarListValueChanged

    private void yVarListValueChanged(javax.swing.event.ListSelectionEvent evt)//GEN-FIRST:event_yVarListValueChanged
    {//GEN-HEADEREND:event_yVarListValueChanged
        mResponseIdx = yVarList.getSelectedIndex();
        updateInfo();
    }//GEN-LAST:event_yVarListValueChanged

    private void saveModelBtnActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_saveModelBtnActionPerformed
    {//GEN-HEADEREND:event_saveModelBtnActionPerformed
        JFileChooser fileChooser = new JFileChooser();
        
        fileChooser.setCurrentDirectory(new File(System.getProperty("user.dir")));
        fileChooser.addChoosableFileFilter(new FileNameExtensionFilter("csv files (*.csv)", "csv"));
        fileChooser.setAcceptAllFileFilterUsed(true);
        
        // set the default output file name
        String fname = mDataFile.substring(mDataFile.lastIndexOf('\\') + 1);
        fname = fname.substring(0, fname.indexOf('.')) + "_TrainedOutput.csv"; 
        fileChooser.setSelectedFile(new File(fname));        
        
        if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) 
        {
            File file = fileChooser.getSelectedFile();            
            fname = file.getPath();
                        
            // check that the file has an extension
            if (fname.indexOf('.') < 0)
            {
                fname = fname + ".csv";
            }
            
            // check to see if the file exists
            if ((new File(fname)).exists())
            {
                int result = JOptionPane.showConfirmDialog(null, "The Model data file:\n\n" + fname + "\n\nalready exists, overwrite?", 
                                                                 "ModelFit - Save Model", JOptionPane.YES_NO_CANCEL_OPTION);                
                // overwrite existing file
                if (result == JOptionPane.YES_OPTION)
                {
                    // generate and write the model output in CSV format
                    generateCSVOutput(fname);                    
                }
            }
            else
            {
                // generate and write the model output in CSV format
                generateCSVOutput(fname);
            }
        }
    }//GEN-LAST:event_saveModelBtnActionPerformed

    private void saveNetworkBtnActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_saveNetworkBtnActionPerformed
    {//GEN-HEADEREND:event_saveNetworkBtnActionPerformed
        JFileChooser fileChooser = new JFileChooser();
        
        fileChooser.setCurrentDirectory(new File(System.getProperty("user.dir")));
        fileChooser.addChoosableFileFilter(new FileNameExtensionFilter("net files (*.net)", "net"));
        fileChooser.setAcceptAllFileFilterUsed(true);
        
        // set the default output file name
        String fname = mDataFile.substring(mDataFile.lastIndexOf('\\') + 1);
        fname = fname.substring(0, fname.indexOf('.')) + "_TrainedNetwork.net"; 
        fileChooser.setSelectedFile(new File(fname));        
        
        if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) 
        {
            File file = fileChooser.getSelectedFile();
            fname = file.getPath();
            
            // check that the file has an extension
            if (fname.indexOf('.') < 0)
            {
                fname = fname + ".net";
            }
            
            // check to see if the file exists
            if ((new File(fname)).exists())
            {
                int result = JOptionPane.showConfirmDialog(null, "The Network file:\n\n" + fname + "\n\nalready exists, overwrite?", 
                                                                 "ModelFit - Save Network", JOptionPane.YES_NO_CANCEL_OPTION);                
                // overwrite existing file
                if (result == JOptionPane.YES_OPTION)
                {
                    // write the network to the file
                    mNet.writeToFile(fname);
                }
            }
            else
            {
                // write the network to the file
                mNet.writeToFile(fname);
            }
        }
    }//GEN-LAST:event_saveNetworkBtnActionPerformed

    private void outFuncListValueChanged(javax.swing.event.ListSelectionEvent evt)//GEN-FIRST:event_outFuncListValueChanged
    {//GEN-HEADEREND:event_outFuncListValueChanged
        updateInfo();
    }//GEN-LAST:event_outFuncListValueChanged

    private void hidFuncListValueChanged(javax.swing.event.ListSelectionEvent evt)//GEN-FIRST:event_hidFuncListValueChanged
    {//GEN-HEADEREND:event_hidFuncListValueChanged
        updateInfo();
    }//GEN-LAST:event_hidFuncListValueChanged

    private void outSlopeSpinnerStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_outSlopeSpinnerStateChanged
    {//GEN-HEADEREND:event_outSlopeSpinnerStateChanged
        updateInfo();
    }//GEN-LAST:event_outSlopeSpinnerStateChanged

    private void outAmpSpinnerStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_outAmpSpinnerStateChanged
    {//GEN-HEADEREND:event_outAmpSpinnerStateChanged
        updateInfo();
    }//GEN-LAST:event_outAmpSpinnerStateChanged

    private void hidSlopeSpinnerStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_hidSlopeSpinnerStateChanged
    {//GEN-HEADEREND:event_hidSlopeSpinnerStateChanged
        updateInfo();
    }//GEN-LAST:event_hidSlopeSpinnerStateChanged

    private void hidAmpSpinnerStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_hidAmpSpinnerStateChanged
    {//GEN-HEADEREND:event_hidAmpSpinnerStateChanged
        updateInfo();
    }//GEN-LAST:event_hidAmpSpinnerStateChanged

    private void learnConstSpinnerStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_learnConstSpinnerStateChanged
    {//GEN-HEADEREND:event_learnConstSpinnerStateChanged
        updateInfo();
    }//GEN-LAST:event_learnConstSpinnerStateChanged

    private void momentSpinnerStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_momentSpinnerStateChanged
    {//GEN-HEADEREND:event_momentSpinnerStateChanged
        updateInfo();
    }//GEN-LAST:event_momentSpinnerStateChanged

    private void minErrorSpinnerStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_minErrorSpinnerStateChanged
    {//GEN-HEADEREND:event_minErrorSpinnerStateChanged
        updateInfo();
    }//GEN-LAST:event_minErrorSpinnerStateChanged

    private void numIterSpinnerStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_numIterSpinnerStateChanged
    {//GEN-HEADEREND:event_numIterSpinnerStateChanged
        updateInfo();
    }//GEN-LAST:event_numIterSpinnerStateChanged

    private void scaleFacSpinnerStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_scaleFacSpinnerStateChanged
    {//GEN-HEADEREND:event_scaleFacSpinnerStateChanged
        updateInfo();
    }//GEN-LAST:event_scaleFacSpinnerStateChanged

    private void initRangeSpinnerStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_initRangeSpinnerStateChanged
    {//GEN-HEADEREND:event_initRangeSpinnerStateChanged
        updateInfo();
    }//GEN-LAST:event_initRangeSpinnerStateChanged

    private void numUnitsSpinnerStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_numUnitsSpinnerStateChanged
    {//GEN-HEADEREND:event_numUnitsSpinnerStateChanged
        updateInfo();
    }//GEN-LAST:event_numUnitsSpinnerStateChanged
    
    /////////////////////////////////////////////////////////////////////
    // Private Helper Methods
    /////////////////////////////////////////////////////////////////////

    /**
     * Constructs and trains a neural network, using the user selected settings,
     * to fit a model to the selected dataset.
     * 
     * Training continues until the maximum number of iterations has been 
     * exceeded or the total network error is less than the set minimum network 
     * error value.  In the former case the trained neural network is the 
     * network that achieved the minimum network error during the training 
     * process.
     * 
     * @return 0 if successful otherwise -1
     */
    private int fitModel()
    {
        int result = 0;
        int maxIter = getNumIterations();
        boolean converged = false;
        boolean invalidResult = false;
        Double netError = -1.0;
        double minErr = Double.MAX_VALUE;
        double scaleFactor = getScaleFactor();
        double minNetError = getMinimumNetError();
        NeuralNet minNet = new NeuralNet();         // keeps track of the network with the minimum network error
        NNetTrainer trainer = new NNetTrainer();    // this object trains the neural net

        // populate the training set data
        populateTrainingSet();

        // initialize the trainer
        trainer.addNewTrainingSet(mInputVecs, mTargetVecs);
        trainer.setLearningConstant(getLearningConstant());
        trainer.setMomentum(getMomentum());

        // clear the neural network ready to fit the model data
        mNet.clearNeuralNetwork();

        // initialize the network
        mNet.setNumInputs(1);                          // a single input value (the 'x-value')
        mNet.setNumOutputs(1);                         // a single output value (the 'y-value')
        mNet.setOutputUnitType(getOutputUnitType());
        mNet.setOutputUnitSlope(getOutputSlope());
        mNet.setOutputUnitAmplify(getOutputAmplify());

        // use a fixed architecture of one hidden layer
        mNet.addLayer(getNumberOfUnits(), getHiddenUnitType(), getInitialRange(), getHiddenSlope(), getHiddenAmplify());

        // carry out the training
        for (int i = 1; i <= maxIter; i++)
        {
            trainer.trainNeuralNet(mNet);
            netError = trainer.getNetError() * scaleFactor;

            // check for an invalid result from the network trainer            
            if (netError.isNaN() || netError.isInfinite())
            {
                String strNetError = String.format("%.4f", netError);
                JOptionPane.showMessageDialog(null, "The network trainer has produced an invalid result:\nNetwork Error = " + strNetError +
                                                    "\nThe training process has been stopped.\nPlease adjust the model settings and try again.", 
                                                    "ModelFit", JOptionPane.ERROR_MESSAGE);

                invalidResult = true;
                result = -1;
                break;
            }

            if (netError < minNetError)
            {
                // the solution has converged
                JOptionPane.showMessageDialog(null, "The solution has converged after " + Integer.toString(i) + " iterations.", 
                                                    "ModelFit", JOptionPane.INFORMATION_MESSAGE);

                // update the status bar
                String strNetError = String.format("%.4f", netError);
                iterationsLabel.setText(" Iterations: " + Integer.toString(i) + " - Minimum Error: " + strNetError);

                converged = true;
                break;
            }

            // keep track of the minimum error value
            if (netError < minErr)
            {
                // copy the state of the neural net at the minimum error value
                minNet.copyNeuralNet(mNet);
                minErr = netError;
            }

            // show the current progress
            if (i % 100 == 0)
            {
                // update the iterations info label                
                String strNetError = String.format("%.4f", netError);
                iterationsLabel.setText("Iterations: " + Integer.toString(i) + " - Network Error: " + strNetError);
                iterationsLabel.update(iterationsLabel.getGraphics());
            }

            trainer.resetNetError();
        }

        if (!converged && !invalidResult)
        {
            // the solution has not converged within the given number of iterations
            String strMinErr = String.format("%.4f", minErr);
            JOptionPane.showMessageDialog(null, "The solution has not converged.\n" +
                                                "The minimum error value was: " + strMinErr + "\n" +
                                                "The neural network that achieved this minimum will be used to fit the model.", 
                                                "ModelFit", JOptionPane.INFORMATION_MESSAGE);

            // copy the net with settings at the minimum error value
            mNet.copyNeuralNet(minNet);

            // update the status bar
            iterationsLabel.setText("Iterations: " + Integer.toString(maxIter) + " - Minimum Error: " + strMinErr);
        }

        return result;
    }

    /**
     * Populates the training set input and target vectors.
     * 
     * The input and target vectors are extracted from the database table and 
     * stored within a list so that they can be used by the neural network 
     * training routine. The values are also scaled - scaling the magnitude 
     * of the data values to fall within the range 0-1 can improve the model 
     * fit.
     */
    private void populateTrainingSet()
    {
        if (mPredictorIdx != -1 && mResponseIdx != -1)
        {
            // we are only using single input and target values in this application but 
            // the neural net allows for multiple input and target values using a list
            // so the single x- and y-values are stored in a list with only one element
            ArrayList<Double> dX = new ArrayList<>();
            ArrayList<Double> dY = new ArrayList<>();

            // clear the training set data
            mInputVecs.clear();
            mTargetVecs.clear();

            // read the x-predictor and y-response values from the data table
            mDataTable.getNumericCol(mPredictorIdx, dX);
            mDataTable.getNumericCol(mResponseIdx, dY);

            // get the scale factor from the GUI
            double scaleFactor = getScaleFactor();
            
            // populate the training set input and target vectors
            for (int i = 0; i < dX.size(); i++)
            {
                ArrayList<Double> iVec = new ArrayList<>();
                ArrayList<Double> tVec = new ArrayList<>();

                // scale the training set input and output values
                iVec.add(dX.get(i) / scaleFactor);      // training set input vector
                tVec.add(dY.get(i) / scaleFactor);      // training set target vector

                // the input and target vectors are also stored within a list
                mInputVecs.add(iVec);
                mTargetVecs.add(tVec);
            }
        }
    }
    
    /**
     * Loads the selected data file into an internal DataTable object.
     *
     * The first 100 lines of the data file are also written to a table and
     * displayed in the form's data preview table control. The predictor and 
     * response variables list boxes are also populated with the data file 
     * column headings.
     * 
     * @param filename the full name, including path, of the data file
     */
    private void loadData(String filename)
    {
        // create a data table from the database file containing the training data
        mDataTable.readFromFile(filename, headerCheckBox.isSelected());

        // check that the data has been read from the file without any errors
        if (mDataTable.getNumRows() <= 0 || mDataTable.getNumCols() <= 1)
        {
            JOptionPane.showMessageDialog(null, "The selected file does not appear to be in the correct format.", 
                                                "ModelFit", JOptionPane.ERROR_MESSAGE);
            
            // clear the filename textbox, the data preview control and the variables list boxes
            dataFileTextField.setText(null);
            dataPreviewTable.setModel(new DefaultTableModel());                        
            xVarList.setModel(new DefaultListModel());
            yVarList.setModel(new DefaultListModel());
            iterationsLabel.setText(" ");
            
            // update the information text label
            infoLabel.setText("Please select a data file");
        }
        else
        {
            // set the data file name (after the data has successfully loaded)
            mDataFile = filename;
            dataFileTextField.setText(mDataFile);
            
            // populate the data preview
            populatePreviewTable();
            
            // populate the x and y variable list boxes
            populateVariableListBoxes();

            // update the information text label
            infoLabel.setText("Please select the variables");
            iterationsLabel.setText(" ");
        }
    }
    
    /**
     * Populates the preview data table with the first 100 lines of the 
     * selected data file.
     */
    private void populatePreviewTable()
    {
        DefaultTableModel model = new DefaultTableModel();

        // get the table column names
        ArrayList<String> colNames = new ArrayList<>();
        mDataTable.getColumnNames(colNames);

        if (colNames.size() > 0)
        {
            // add the data file column names to the preview table
            for (int i = 0; i < colNames.size(); i++)
            {
                model.addColumn(colNames.get(i));
            }
        }
        else
        {
            // use generic column names
            for (int i = 0; i < mDataTable.getNumCols(); i++)
            {
                String columnName = "Column " + Integer.toString(i + 1);
                model.addColumn(columnName);
            }            
        }
        
        // populate the preview table with up to the first 100 rows of the DataTable
        int numRows = 100;

        if (mDataTable.getNumRows() < 100)
        {
            // the table has less than 100 rows
            numRows = mDataTable.getNumRows();
        }
        
        // add the row data to the preview table
        for (int i = 0; i < numRows; i++)
        {                        
            // get the row data
            ArrayList<Double> row = new ArrayList<>();
            mDataTable.getNumericRow(i, row);
            
            Double[] rowVals = new Double[mDataTable.getNumCols()];
            
            for (int j = 0; j < mDataTable.getNumCols(); j++)
            {
                rowVals[j] = row.get(j);
            }
            
            model.addRow(rowVals);
        }
        
        // add the minimum and maximum values from each column to the preview table
        ArrayList<Double> column = new ArrayList<>();
        
        for (int i = 0; i < 2; i++)
        {
            Double[] rowVals = new Double[mDataTable.getNumCols()];
            
            for (int j = 0; j < mDataTable.getNumCols(); j++)
            {
                // get the column data
                column.clear();
                mDataTable.getNumericCol(j, column);

                double minMaxvalue = 0;

                if (i == 0 && column.size() > 0)
                {
                    // get the column minimum value
                    minMaxvalue = Collections.min(column);
                }
                else if (i == 1 && column.size() > 0)
                {
                    // get the column maximum value
                    minMaxvalue = Collections.max(column);
                }

                rowVals[j] = minMaxvalue;
            }
            
            model.addRow(rowVals);
        }
        
        dataPreviewTable.removeAll();
        dataPreviewTable.setModel(model);
    }
    
    /**
     * Applies the trained neural network model to the selected predictor input 
     * data and outputs the results to a .csv file.
     * 
     * The output consists of 3 columns - the first contains the selected
     * training set input (or predictor) values, the second the selected 
     * training set target values and the third contains the trained model 
     * output responses to the given input values.
     * 
     * @param fname the name of the file to write the results to
     */
    private void generateCSVOutput(String fname)
    {
        String comma = ",";
        String newLine = "\n";
        int size = mInputVecs.size();
        double scaleFactor = getScaleFactor();
        ArrayList<Double> dX = new ArrayList<>();
        ArrayList<Double> dM = new ArrayList<>();
                
        try (FileOutputStream ofstream = new FileOutputStream(fname))
        {
            // output the column titles
            ArrayList<String> colNames = new ArrayList<>();
            mDataTable.getColumnNames(colNames);
            String header = colNames.get(mPredictorIdx).trim() + "," + colNames.get(mResponseIdx).trim() + ",model\n";
            ofstream.write(header.getBytes());
            
            for (int i = 0; i < size; i++)
            {
                dX.addAll(mInputVecs.get(i));
                
                // calculate the model response m-values given the input x-values from the validation set
                mNet.getResponse(dX, dM);

                // the required values are stored in vectors and need re-scaling
                double xValue = dX.get(0) * scaleFactor;
                double yValue = mTargetVecs.get(i).get(0) * scaleFactor;
                double mValue = dM.get(0) * scaleFactor;
                                
                String sXval = String.format("%.8f", xValue);
                String sYval = String.format("%.8f", yValue);
                String sMval = String.format("%.8f", mValue);
                        
                ofstream.write(sXval.getBytes());
                ofstream.write(comma.getBytes());
                ofstream.write(sYval.getBytes());
                ofstream.write(comma.getBytes());
                ofstream.write(sMval.getBytes());
                ofstream.write(newLine.getBytes());

                dX.clear();
            }

            // tidy up
            ofstream.close();
        }
        catch (IOException ex)
        {
            JOptionPane.showMessageDialog(null, "ERROR: Writing to file: " + fname + "\n" + ex.getMessage(),
                                                "ModelFit", JOptionPane.ERROR_MESSAGE);
        }        
    }
    
    /**
     * Populates the forms Predictor and Response variables list boxes with 
     * the data file column headings. 
     */
    private void populateVariableListBoxes()
    {
        // clear the list boxes
        xVarList.removeAll();
        yVarList.removeAll();
        
        if (mDataTable.getHeader())
        {
            // populate the list boxes with the data header row
            ArrayList<String> colNames = new ArrayList<>();
            mDataTable.getColumnNames(colNames);

            String[] vars = new String[colNames.size()];
                        
            for (int i = 0; i < colNames.size(); i++)
            {
                vars[i] = colNames.get(i);
            }
            
            xVarList.setListData(vars);
            yVarList.setListData(vars);
            
            // make sure the background colour of the list boxes is white
            xVarList.setBackground(Color.WHITE);
            yVarList.setBackground(Color.WHITE);
        }
        else
        {
            // populate the list boxes with generic column ids
            String[] vars = new String[mDataTable.getNumCols()];
            
            for (int i = 0; i < mDataTable.getNumCols(); i++)
            {
                String name = "Column " + Integer.toString(i + 1);
                vars[i] = name;
            }
            
            xVarList.setListData(vars);
            yVarList.setListData(vars);
        }
    }

    /**
     * Populates the form's Activation Function list boxes with the available 
     * values of the ActiveT enumerated type.
     */
    private void populateActivationListBoxes()
    {
        int id = 0;
        boolean done = false;
        ArrayList<String> activeValues;
        activeValues = new ArrayList<>();
        
        // get all the available ActiveT enum string values
        while (!done)
        {
            String funcName = ActiveT.intToString(id);

            if ("Unknown".equals(funcName))
            {
                // we have processed all the valid ActiveT enum values
                done = true;
            }
            else
            {
                activeValues.add(funcName);
                id++;
            }
        }

        // add the ActiveT string values to the activation function list boxes
        if (id > 0)
        {
            String[] funcs = new String[id];

            for (int i = 0; i < id; i++)
            {
                funcs[i] = activeValues.get(i);
            }

            outFuncList.setListData(funcs);
            hidFuncList.setListData(funcs);
            
            // select the first function in the list
            outFuncList.setSelectedIndex(0);
            hidFuncList.setSelectedIndex(0);
        }                
    }
    
    /**
     * Gets the value of the learning constant spinner control.
     * 
     * @return the value selected by the user
     */
    private double getLearningConstant()
    {
        return (Double)learnConstSpinner.getValue();
    }

    /**
     * Gets the value of the momentum spinner control.
     * 
     * @return the value selected by the user
     */    
    private double getMomentum()
    {
        return (Double)momentSpinner.getValue();
    }

    /**
     * Gets the value of the minimum network error spinner control.
     * 
     * @return the value selected by the user
     */    
    private double getMinimumNetError()
    {
        return (Double)minErrorSpinner.getValue();
    }
    
    /**
     * Gets the value of the number of iterations spinner control.
     * 
     * @return the value selected by the user
     */    
    private int getNumIterations()
    {        
        return (Integer)numIterSpinner.getValue();
    }

    /**
     * Gets the value of the scale factor spinner control.
     * 
     * @return the value selected by the user
     */    
    private double getScaleFactor()
    {
        return (Double)scaleFacSpinner.getValue();
    }

    /**
     * Gets the value of the initial range spinner control.
     * 
     * @return the value selected by the user
     */    
    private double getInitialRange()
    {
        return (Double)initRangeSpinner.getValue();
    }

    /**
     * Gets the value of the number of hidden units spinner control.
     * 
     * @return the value selected by the user
     */    
    private int getNumberOfUnits()
    {
        return (Integer)numUnitsSpinner.getValue();
    }

    /**
     * Gets the value of the output layer slope parameter spinner control.
     * 
     * @return the value selected by the user
     */    
    private double getOutputSlope()
    {
        return (Double)outSlopeSpinner.getValue();
    }
    /**
     * Gets the value of the hidden layer slope parameter spinner control.
     * 
     * @return the value selected by the user
     */    
    private double getHiddenSlope()
    {
        return (Double)hidSlopeSpinner.getValue();
    }

    /**
     * Gets the value of the output layer amplify parameter spinner control.
     * 
     * @return the value selected by the user
     */        
    private double getOutputAmplify()
    {
        return (Double)outAmpSpinner.getValue();
    }

    /**
     * Gets the value of the hidden layer amplify parameter spinner control.
     * 
     * @return the value selected by the user
     */        
    private double getHiddenAmplify()
    {
        return (Double)hidAmpSpinner.getValue();
    }
    
    /**
     * Gets the ActiveT enumeration corresponding to the index of the selected
     * item in the Output Layer Activation function list box.
     * 
     * @return the selected function type enumerated value
     */        
    private ActiveT getOutputUnitType()
    {
        return ActiveT.intToActiveT(outFuncList.getSelectedIndex());
    }

    /**
     * Gets the ActiveT enumeration corresponding to the index of the selected
     * item in the Hidden Layer Activation function list box.
     * 
     * @return the selected function type enumerated value
     */        
    private ActiveT getHiddenUnitType()
    {
        return ActiveT.intToActiveT(hidFuncList.getSelectedIndex());
    }
    
    /**
     * Updates the information label control and enables the Fit Model button
     * once the user has set the minimum required fields.
     */
    private void updateInfo()
    {
        if (mPredictorIdx != -1 && mResponseIdx != -1)
        {
            // update the information text label
            infoLabel.setText("You can now fit the model");
            
            // enable the fit model button
            if (fitModelBtn.isEnabled() == false)
            {
                fitModelBtn.setEnabled(true);
            }
            
            iterationsLabel.setText(" ");
        }
        
        saveModelBtn.setEnabled(false);
        saveNetworkBtn.setEnabled(false);
    }
    
    /////////////////////////////////////////////////////////////////////
    /**
     * The main entry point for the application.
     * 
     * @param args the command line arguments
     */
    public static void main(String args[])
    {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try
        {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels())
            {
                if ("Nimbus".equals(info.getName()))
                {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex)
        {
            java.util.logging.Logger.getLogger(ModelFitJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex)
        {
            java.util.logging.Logger.getLogger(ModelFitJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex)
        {
            java.util.logging.Logger.getLogger(ModelFitJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex)
        {
            java.util.logging.Logger.getLogger(ModelFitJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable()
        {
            public void run()
            {
                new ModelFitJFrame().setVisible(true);
            }
        });
    }

    /////////////////////////////////////////////////////////////////////
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField dataFileTextField;
    private javax.swing.JTable dataPreviewTable;
    private javax.swing.JButton exitBtn;
    private javax.swing.JButton fileBrowseBtn;
    private javax.swing.JButton fitModelBtn;
    private javax.swing.JCheckBox headerCheckBox;
    private javax.swing.JSpinner hidAmpSpinner;
    private javax.swing.JList<String> hidFuncList;
    private javax.swing.JSpinner hidSlopeSpinner;
    private javax.swing.JLabel infoLabel;
    private javax.swing.JSpinner initRangeSpinner;
    private javax.swing.JLabel iterationsLabel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane7;
    private javax.swing.JSpinner learnConstSpinner;
    private javax.swing.JSpinner minErrorSpinner;
    private javax.swing.JSpinner momentSpinner;
    private javax.swing.JSpinner numIterSpinner;
    private javax.swing.JSpinner numUnitsSpinner;
    private javax.swing.JSpinner outAmpSpinner;
    private javax.swing.JList<String> outFuncList;
    private javax.swing.JSpinner outSlopeSpinner;
    private javax.swing.JButton saveModelBtn;
    private javax.swing.JButton saveNetworkBtn;
    private javax.swing.JSpinner scaleFacSpinner;
    private javax.swing.JLabel statusLabel;
    private javax.swing.JList<String> xVarList;
    private javax.swing.JList<String> yVarList;
    // End of variables declaration//GEN-END:variables
}
